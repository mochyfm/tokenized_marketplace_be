import * as fs from 'fs';
import * as crypto from 'crypto';
import { JWT_CONSTANTS } from 'src/constants/security.constants';
import { BKND_CONSTANTS } from 'src/constants/backend.constants';

/**
 * Ensures that JWT_SECRET is present in the .env file, adding it if necessary.
 *
 * @param {number} [secretKeySize=32] - The size of the secret key to generate, in bytes. Default is 32.
 * @returns {void}
 */
export function ensureJwtSecretInEnv(secretKeySize: number = 32): void {
  /**
   * Generates a random secret key.
   *
   * @returns {string} - The generated secret key.
   */
  const generateSecretKey = (): string =>
    crypto.randomBytes(secretKeySize).toString('hex');

  // Check if the .env file exists, if not, create it
  if (!fs.existsSync(BKND_CONSTANTS.envFilePath)) {
    fs.writeFileSync(BKND_CONSTANTS.envFilePath, '');
  }

  // Check if the .env file contains JWT_SECRET
  const envFileContent = fs.readFileSync(BKND_CONSTANTS.envFilePath, 'utf-8');
  const jwtComment =
    '# Encrypted code generated by the application, remove and re-launch if you want a new one\n';

  if (!envFileContent.includes(JWT_CONSTANTS.jwtSecretEnvVariable)) {
    if (!envFileContent.includes(jwtComment)) {
      fs.appendFileSync(BKND_CONSTANTS.envFilePath, `\n${jwtComment}`);
    }

    // Check if the comment already exists
    // Generate a secret key
    const secretKey = generateSecretKey();

    // Append JWT_SECRET to the .env file
    fs.appendFileSync(
      BKND_CONSTANTS.envFilePath,
      `${JWT_CONSTANTS.jwtSecretEnvVariable}=${secretKey}\n`,
    );
  }
}
